# 操作系统相关

## 一、进程间通信方式

+ 管道(pipe)：允许一个进程和另一个与它有共同祖先的进程之间进行通信
+ 命名管道(FIFO)：类似于管道，但是它可以用于任何两个进程之间的通信，命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建
+ 消息队列(MQ)：消息队列是消息的连接表，包括POSIX消息对和System V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能成该无格式字节流以及缓冲区大小受限等缺点；
+ 信号量(semaphore)：信号量主要作为进程间以及同进程不同线程之间的同步手段；
+ 共享内存(shared memory)：它使得多个进程可以访问同一块内存空间，**是最快的可用IPC形式。**这是针对其他通信机制运行效率较低而设计的。它往往与其他通信机制，如信号量结合使用，以达到进程间的同步及互斥
+ 信号(signal)：信号是比较复杂的通信方式，用于通知接收进程有某种事情发生，除了用于进程间通信外，进程还可以发送信号给进程本身
+ 内存映射(mapped memory)：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它
+ 套接字(Socket)：它是更为通用的进程间通信机制，可用于不同机器之间的进程间通信

## 二、线程间通信方式

### Linux

+ 信号：类似进程间的信号处理
+ 锁机制：互斥锁、读写锁和自旋锁
+ 条件变量：使用通知的方式解锁，与互斥锁配合使用
+ 信号量：包括无名线程信号量和命名线程信号量  

### Windows

+ 全局变量：需要有多个线程来访问一个全局变量时，通常我们会在这个全局变量前加上volatile声明，以防编译器对此变量进行优化
+ Message消息机制：常用的Message通信的接口主要有两个：PostMessage和PostThreadMessage，PostMessage为线程向主窗口发送消息。而PostThreadMessage是任意两个线程之间的通信接口。
+ CEvent对象：CEvent为MFC中的一个对象，可以通过对CEvent的触发状态进行改变，从而实现线程间的通信和同步，这个主要是实现线程直接同步的一种方法。

## 三、线程切换时上下文保存在哪里

### 1.内核级线程上下文

当操作系统进行线程切换时，它会保存当前线程的上下文（CPU寄存器状态等）并恢复下一个线程的上下文。这通常涉及以下步骤：

+ CPU寄存器：包括程序计数器（PC）、堆栈指针（SP）、基指针（BP）以及其他通用寄存器的值。这些寄存器保存了线程的执行状态（即执行到哪里）。
+ 线程的堆栈：每个线程有自己的堆栈，用于存储局部变量、函数调用返回地址等信息。线程切换时，操作系统保存当前线程的堆栈指针并恢复下一个线程的堆栈指针。
操作系统通过将这些信息保存到 内核栈 或 内核缓冲区（通常是一个数据结构）中来实现线程的上下文保存。

### 2.线程控制块（TCB，Thread Control Block）

线程控制块是操作系统用于管理线程的一个数据结构，它包含了一个线程的所有元数据，包括线程的上下文信息。线程切换时，操作系统会保存和恢复线程的上下文信息（如寄存器、程序计数器、堆栈指针等）到对应的 TCB 中。  
每个线程在操作系统中都会有一个与之关联的 线程控制块。当线程被切换出去时，操作系统会把当前线程的状态（上下文）保存在其 TCB 中，并在需要恢复该线程时从 TCB 中恢复上下文。  
TCB 可能包含的信息：

+ CPU寄存器的值
+ 程序计数器（PC）和指令指针（IP）
+ 堆栈指针（SP）和基指针（BP）
+ 当前线程的堆栈信息
+ 调度状态（如线程是否就绪、阻塞等）
+ 优先级、线程标识符等  

### 3.用户态线程的上下文保存

在 用户态线程（例如通过 pthread 或 std::thread 实现的线程）中，线程的上下文可以通过类似 setjmp/longjmp 或 ucontext_t 等机制进行保存和恢复。这些机制通常由线程库实现，用于在用户态进行线程切换时保存和恢复上下文。

在这种情况下，线程上下文（包括寄存器的值和堆栈）通常保存在特定的数据结构中，操作系统不会直接介入这些线程的切换，而是交由线程库处理。

### 4.硬件支持

在硬件层面，现代CPU提供了硬件级别的上下文切换支持。当发生中断或上下文切换时，CPU的硬件机制（如中断向量表、上下文保存寄存器）会自动保存当前执行线程的寄存器值，并加载新线程的寄存器值。

操作系统只需要在发生上下文切换时通知硬件，硬件会自动处理寄存器的保存和恢复，而操作系统则负责更新调度队列和线程的状态。

### 5.上下文切换的性能

上下文切换涉及保存和恢复寄存器、更新堆栈指针、操作内核数据结构等步骤。过于频繁的上下文切换会带来性能开销，因为它需要 CPU 执行额外的工作（比如保存/恢复上下文、更新调度数据结构等）。因此，现代操作系统通常会尽量避免频繁的上下文切换，尤其是在没有充分的并行任务时。

### 总结

线程上下文的保存位置依赖于操作系统的实现，但一般来说，线程的上下文会被保存在以下几个地方：

+ 内核栈（在内核级线程的情况下）
+ 线程控制块（TCB）：包含了线程的状态、寄存器值、堆栈指针等
+ CPU寄存器：在硬件级别进行保存和恢复
+ 线程库的内部数据结构（在用户态线程的情况下）
+ 上下文切换的开销和性能取决于操作系统的调度策略以及线程库的实现。
