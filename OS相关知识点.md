# 操作系统相关

## 一、进程间通信方式

+ 管道(pipe)：允许一个进程和另一个与它有共同祖先的进程之间进行通信
+ 命名管道(FIFO)：类似于管道，但是它可以用于任何两个进程之间的通信，命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建
+ 消息队列(MQ)：消息队列是消息的连接表，包括POSIX消息对和System V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能成该无格式字节流以及缓冲区大小受限等缺点；
+ 信号量(semaphore)：信号量主要作为进程间以及同进程不同线程之间的同步手段；
+ 共享内存(shared memory)：它使得多个进程可以访问同一块内存空间，**是最快的可用IPC形式。**这是针对其他通信机制运行效率较低而设计的。它往往与其他通信机制，如信号量结合使用，以达到进程间的同步及互斥
+ 信号(signal)：信号是比较复杂的通信方式，用于通知接收进程有某种事情发生，除了用于进程间通信外，进程还可以发送信号给进程本身
+ 内存映射(mapped memory)：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它
+ 套接字(Socket)：它是更为通用的进程间通信机制，可用于不同机器之间的进程间通信

## 二、线程间通信方式

### Linux

+ 信号：类似进程间的信号处理
+ 锁机制：互斥锁、读写锁和自旋锁
+ 条件变量：使用通知的方式解锁，与互斥锁配合使用
+ 信号量：包括无名线程信号量和命名线程信号量  

### Windows

+ 全局变量：需要有多个线程来访问一个全局变量时，通常我们会在这个全局变量前加上volatile声明，以防编译器对此变量进行优化
+ Message消息机制：常用的Message通信的接口主要有两个：PostMessage和PostThreadMessage，PostMessage为线程向主窗口发送消息。而PostThreadMessage是任意两个线程之间的通信接口。
+ CEvent对象：CEvent为MFC中的一个对象，可以通过对CEvent的触发状态进行改变，从而实现线程间的通信和同步，这个主要是实现线程直接同步的一种方法。

## 三、线程切换时上下文保存在哪里

### 1.内核级线程上下文

当操作系统进行线程切换时，它会保存当前线程的上下文（CPU寄存器状态等）并恢复下一个线程的上下文。这通常涉及以下步骤：

+ CPU寄存器：包括程序计数器（PC）、堆栈指针（SP）、基指针（BP）以及其他通用寄存器的值。这些寄存器保存了线程的执行状态（即执行到哪里）。
+ 线程的堆栈：每个线程有自己的堆栈，用于存储局部变量、函数调用返回地址等信息。线程切换时，操作系统保存当前线程的堆栈指针并恢复下一个线程的堆栈指针。
操作系统通过将这些信息保存到 **内核栈** 或 **内核缓冲区**（通常是一个数据结构）中来实现线程的上下文保存。

### 2.线程控制块（TCB，Thread Control Block）

线程控制块是操作系统用于管理线程的一个数据结构，它包含了一个线程的所有元数据，包括线程的上下文信息。线程切换时，操作系统会保存和恢复线程的上下文信息（如寄存器、程序计数器、堆栈指针等）到对应的 TCB 中。  
每个线程在操作系统中都会有一个与之关联的 线程控制块。当线程被切换出去时，操作系统会把当前线程的状态（上下文）保存在其 **TCB** 中，并在需要恢复该线程时从 TCB 中恢复上下文。  
TCB 可能包含的信息：

+ CPU寄存器的值
+ 程序计数器（PC）和指令指针（IP）
+ 堆栈指针（SP）和基指针（BP）
+ 当前线程的堆栈信息
+ 调度状态（如线程是否就绪、阻塞等）
+ 优先级、线程标识符等  

### 3.用户态线程的上下文保存

在 用户态线程（例如通过 pthread 或 std::thread 实现的线程）中，线程的上下文可以通过类似 setjmp/longjmp 或 ucontext_t 等机制进行保存和恢复。这些机制通常由线程库实现，用于在用户态进行线程切换时保存和恢复上下文。

在这种情况下，线程上下文（包括寄存器的值和堆栈）通常保存在**特定的数据结构**中，操作系统不会直接介入这些线程的切换，而是交由线程库处理。

### 4.硬件支持

在硬件层面，现代CPU提供了硬件级别的上下文切换支持。当发生中断或上下文切换时，CPU的硬件机制（如中断向量表、上下文保存寄存器）会自动保存当前执行线程的寄存器值，并加载新线程的寄存器值。

操作系统只需要在发生上下文切换时通知硬件，**硬件会自动处理**寄存器的保存和恢复，而操作系统则负责更新调度队列和线程的状态。

### 5.上下文切换的性能

上下文切换涉及保存和恢复寄存器、更新堆栈指针、操作内核数据结构等步骤。过于频繁的上下文切换会带来性能开销，因为它需要 CPU 执行额外的工作（比如保存/恢复上下文、更新调度数据结构等）。因此，现代操作系统通常会尽量避免频繁的上下文切换，尤其是在没有充分的并行任务时。

### 总结

线程上下文的保存位置依赖于操作系统的实现，但一般来说，线程的上下文会被保存在以下几个地方：

+ 内核栈（在内核级线程的情况下）
+ 线程控制块（TCB）：包含了线程的状态、寄存器值、堆栈指针等
+ CPU寄存器：在硬件级别进行保存和恢复
+ 线程库的内部数据结构（在用户态线程的情况下）
+ 上下文切换的开销和性能取决于操作系统的调度策略以及线程库的实现。

## 四、多线程为什么可以加快下载速度

### 实时网络带宽

决定用户下载大文件速度快慢的终极因素，在于用户下载进程实时抢占网络带宽的大小。其它的因素与它相比，可以忽略不计。

  如果用户进程实时抢占的带宽 = 实时网络可用带宽，则在最理想的状态下，用户下载进程100%利用网络带宽，无论该下载进程是单线程（Thread）的还是多线程的，下载速度几乎没有任何区别。【因为此时没有别的进程使用网络带宽】。

  但是在现实中实际是用户进程实时抢占的带宽 <= 实时网络可用带宽！因为实时网络带宽每一刻都是在变化的，那它是怎么变化的呢？因为TCP流量控制。

### TCP流量控制

  传统的TCP流量探测机制有一个非常致命的缺陷：一旦检测到有丢包，立马将发送速率降为1/2。降速1/2后，如果没有丢包，将会在1/2速率的基础上，按照固定的增长值（线性增长），加大发送的速率。接下来就会一直按照这个节奏到达丢包的那一刻（实时可用带宽）为止。如果下一个检测周期依然有丢包现象，会在当前1/2速率的基础上继续降速1/2。循环往复，直到文件下载结束。

  很显然指数级的降速、但是线性的增速；这最后造成的结果就是真实的传输速率远远小于实时可用带宽。

### 多线程下载

  多线程下载时，由于多个线程在竞争实时可用带宽。尽管多线程逻辑上是并行的，但其实还是按时序的串行处理。所以每个线程处于的阶段并不一致。并且带宽资源是固定的。

  比如使用3个线程来进行下载，因为处于不同的阶段，有的线程因为丢包直接降速1/2，有的线程处于线性增长阶段。通过多个线程的加权平均，最后得到的下载曲线是一条平滑的曲线，且这条曲线大多数应该处于单线程下载速率的上方。这也是为什么多线程下载大文件的速度更快的原因了。

就http1.0协议会使用多个tcp连接进行下载
http2.0可以使用单个tcp连接采用多路复用的技术来多线程下载(多个流，复用保证流能充分利用带宽)

## 五、异常和中断

### 相同点

+ 最后都是由CPU发送给内核，由内核去处理
+ 处理程序的流程的设计上是相似的

### 不同点

+ 产生源不相同，异常是由CPU产生的，而中断主要是由硬件设备产生的（也有软件中断）
+ 内核需要根据是异常还是中断调用不同的处理程序
+ 中断不是时钟同步的，这意味着中断可能随时到来；异常由于是CPU产生的，所以它是时钟同步的
+ 当处理中断时，处于中断上下文中；处理异常时，处于进程上下文中

## 六、系统栈大小

### Windows

+ 32位，默认为1M；64位，默认为4M
+ 由编译器决定，可以通过编译器选项 /F 或链接器参数设置栈大小

### Linux

+ 32位，默认为8M；64位，默认为8M或10M
+ 由系统决定，可以使用 ulimit -s 或编译时链接器选项 -Wl,--stack 设置栈大小
