# 计算机网络相关

## 一、OSI七层模型

+ 物理层：（比特流 Bits）底层数据传输，如网线；网卡标准。
+ 数据链路层：（数据帧 Frames）定义数据的基本格式，如何传输，如何标识；如网卡MAC地址
+ 网络层：（IP数据报 包 Packages）定义IP编址，定义路由功能；如不同设备的数据转发。
+ 传输层：（TCP报文段或UDP用户数据报 Segments）端到端传输数据的基本功能；如 TCP、UDP。
+ 会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件。
+ 表示层：数据格式标识，基本压缩加密功能。
+ 应用层：各种应用软件，包括Web应用 （DNS协议：使用UDP传输）

## 二、Post和Get的区别

+ get是获取数据，post是修改数据
+ get把请求的数据放在url上， 以?分割URL和传输数据，参数之间以&相连，所以get不太安全。而post把数据放在HTTP的包体内（request body 相对安全）
+ get提交的数据最大是2k（ 限制实际上取决于浏览器）， post理论上没有限制。
+ GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); POST产生两个TCP数据包（**部分浏览器和框架的行为，不是Post的必然行为**），浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。
+ GET请求会被浏览器主动缓存，而POST不会，除非手动设置。
+ GET是幂等（多次操作得到一样的结果）的，post不是；所以不应该也不能用get请求做数据的增删改这些有副作用的操作，在网络不好的隧道中GET请求会尝试重试，会有重复操作的风险，可能会导致副作用（浏览器和操作系统并不知道你会用get请求去做增操作）

## 三、浏览器对同一 Host 建立 TCP 连接到的数量的限制

+ Chrome 最多允许对同一个 Host 建立六个 TCP 连接，不同的浏览器有一些区别

## 四、HTTPS的加密方式

+ Client给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。
+ Server确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。
+ Client确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给Server。
+ Server使用自己的私钥，获取Client发来的随机数（Premaster secret）。
+ Client和Server根据约定的加密方法，使用前面的三个随机数，生成”对话密钥”（session key），用来加密接下来的整个对话过程。

## 五、TCP四大拥塞控制算法

### 慢启动

+ 连接建好的开始先初始化拥塞窗口 `cwnd` 大小为1，表明可以传一个MSS大小的数据。
+ 每当收到一个ACK，cwnd大小加一，呈线性上升。
+ 每当过了一个往返延迟时间RTT(Round-Trip Time)，cwnd大小直接翻倍，乘以2，呈指数让升。
+ 还有一个ssthresh（slow start threshold），是一个上限，当cwnd >= ssthresh时，就会进入“拥塞避免算法”（后面会说这个算法）

### 拥塞避免

+ 收到一个ACK，则cwnd = cwnd + 1 / cwnd
+ 每当过了一个往返延迟时间RTT，cwnd大小加一

### 拥塞发生

#### 发生原因

+ 包 checksum 出错（乱序）
+ 网络拥塞
+ 网络断，包括路由重收敛

一般来说，TCP拥塞控制默认认为网络丢包是由于网络拥塞导致的，所以一般的TCP拥塞控制算法以丢包为网络进入拥塞状态的信号。对于丢包有两种判定方式，一种是 **超时重传RTO[Retransmission Timeout]** ，另一个是 **收到三个重复确认ACK**（三次可以排除是乱序的原因）

超时重传是TCP协议保证数据可靠性的一个重要机制，其原理是在发送一个数据以后就开启一个计时器，在一定时间内如果没有得到发送数据报的ACK报文，那么就重新发送数据，直到发送成功为止。

但是如果发送端接收到3个以上的重复ACK，TCP就意识到数据发生丢失，需要重传。这个机制不需要等到重传定时器超时，所以叫做 **快速重传**，而快速重传后没有使用慢启动算法，而是拥塞避免算法，所以这又叫做快速恢复算法。

超时重传RTO[Retransmission Timeout]超时，TCP会重传数据包。TCP认为这种情况比较糟糕，反应也比较强烈：

+ 由于发生丢包，将慢启动阈值ssthresh设置为当前cwnd的一半，即ssthresh = cwnd / 2.
+ cwnd重置为1
+ 进入慢启动过程
 最为早期的TCP Tahoe算法就只使用上述处理办法，但是由于一丢包就一切重来，导致cwnd又重置为1，十分不利于网络数据的稳定传递。

 所以，TCP Reno算法进行了优化。当收到三个重复确认ACK时，TCP开启快速重传Fast Retransmit算法，而不用等到RTO超时再进行重传：

+ cwnd大小缩小为当前的一半
+ ssthresh设置为缩小后的cwnd大小
+ 然后进入快速恢复算法Fast Recovery

### 快速恢复

TCP Tahoe是早期的算法，所以没有快速恢复算法，而Reno算法有。在进入快速恢复之前，cwnd和ssthresh已经被更改为原有cwnd的一半。快速恢复算法的逻辑如下：

+ cwnd = cwnd + 3 MSS，加 3 MSS的原因是因为收到3个重复的ACK。
+ 重传DACKs指定的数据包。
+ 如果再收到DACKs，那么cwnd大小增加一。
+ 如果收到新的ACK，表明重传的包成功了，那么退出快速恢复算法。将cwnd设置为ssthresh，然后进入拥塞避免算法

## 六、流量控制

+ 目的是接收方通过TCP头窗口字段告知发送方本方可接收的最大数据量，用以解决发送速率过快导致接收方不能接收的问题。所以流量控制是点对点控制。

+ TCP是双工协议，双方可以同时通信，所以发送方接收方各自维护一个发送窗和接收窗。

+ 发送窗：用来限制发送方可以发送的数据大小，其中发送窗口的大小由接收端返回的TCP报文段中窗口字段来控制，接收方通过此字段告知发送方自己的缓冲（受系统、硬件等限制）大小。  
+ 接收窗：用来标记可以接收的数据大小。

+ TCP是流数据，发送出去的数据流可以被分为以下四部分：已发送且被确认部分 | 已发送未被确认部分 | 未发送但可发送部分 | 不可发送部分，其中发送窗 = 已发送未确认部分 + 未发但可发送部分。接收到的数据流可分为：已接收 | 未接收但准备接收 | 未接收不准备接收。接收窗 = 未接收但准备接收部分。
+ 发送窗内数据只有当接收到接收端某段发送数据的ACK响应时才移动发送窗，左边缘紧贴刚被确认的数据。接收窗也只有接收到数据且最左侧连续时才移动接收窗口。

## 七、TCP如何保证可靠传输

+ 确认和重传：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就会重传。
+ 数据校验：TCP报文头有校验和，用于校验报文是否损坏。
+ 数据合理分片和排序：tcp会按最大传输单元(MTU)合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层。而UDP：IP数据报大于1500字节，大于MTU。这个时候发送方的IP层就需要分片，把数据报分成若干片，是的每一片都小于MTU。而接收方IP层则需要进行数据报的重组。由于UDP的特性，某一片数据丢失时，接收方便无法重组数据报，导致丢弃整个UDP数据报。
+ 流量控制：当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。
+ 拥塞控制：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。

## 八、CSRF攻击

跨站点请求伪造，指攻击者通过跨站请求，以合法的用户的身份进行非法操作。可以这么理解CSRF攻击：攻击者盗用你的身份，以你的名义向第三方网站发送恶意请求。CRSF能做的事情包括利用你的身份发邮件，发短信，进行交易转账，甚至盗取账号信息。

### 防范方法

+ 安全框架，例如Spring Security。
+ token机制。在HTTP请求中进行token验证，如果请求中没有token或者token内容不正确，则认为CSRF攻击而拒绝该请求。
+ 验证码。通常情况下，验证码能够很好的遏制CSRF攻击，但是很多情况下，出于用户体验考虑，验证码只能作为一种辅助手段，而不是最主要的解决方案。
+ referer识别。在HTTP Header中有一个字段Referer，它记录了HTTP请求的来源地址。如果Referer是其他网站，就有可能是CSRF攻击，则拒绝该请求。但是，服务器并非都能取到Referer。很多用户出于隐私保护的考虑，限制了Referer的发送。在某些情况下，浏览器也不会发送Referer，例如HTTPS跳转到HTTP。

## 九、端口号上限

65536。因为TCP的报文头部中源端口号和目的端口号的长度是16位，也就是可以表示2^16=65536个不同端口号，因此TCP可供识别的端口号最多只有65536个。但是由于0到1023是知名服务端口，所以实际上还要少1024个端口号。  
而对于服务器来说，可以开的端口号与65536无关，其实是受限于Linux可以打开的文件数量，并且可以通过MaxUserPort来进行配置。
