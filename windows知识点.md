# Windows面试问题

## 一、windows的消息机制

windows消息按作用区分，分为3类（窗口消息、命令消息、控件通知消息）：

+ **窗口消息** 大概是系统中最为常见的消息，它是指由操作系统和控制其他窗口的窗口所使用的消息。例如CreateWindow、DestroyWindow和MoveWindow等都会激发窗口消息，还有我们在上面谈到的单击鼠标所产生的消息也是一种窗口消息
+ **命令消息**  这是一种特殊的窗口消息，他用来处理从一个窗口发送到另一个窗口的用户请求，例如按下一个按钮，他就会向主窗口发送一个命令消息
+ **控件通知消息** 其实它是这样滴，当一个窗口内的子控件发生了一些事情，而这些是需要通知父窗口的，此刻它就上场啦。通知消息只适用于标准的窗口控件如按钮、列表框、组合框、编辑框，以及Windows公共控件如树状视图、列表视图等。

从消息的发送途径来看，Windows程序中的消息可以分成2种：队列消息和非队列消息  

+ **队列消息**  
windows维护着一个系统消息队列，以及分别为每个GUI线程维护一个各自的线程消息队列。  
为了避免非GUI线程的创建线程消息队列的开销，所有线程创建初始化时，均不创建消息队列。只有当线程第一次调用GDI函数时，系统才会为线程创建消息队列。所以那些非GUI线程是没有消息队列的。每当用户移动鼠标，点击按钮或键盘时，鼠标或键盘的设备驱动程序会将输入转换成消息，并将消息放在系统消息队列里。然后windows会检查自己的消息队列，如果消息队列不为空，则每次取出并删除一个消息，然后确定消息的目标窗口，然后把消息放到创建这个窗口的线程的线程消息队列里。  
线程的消息队列接收由线程创建的窗口的所有的鼠标和键盘消息，然后线程会从队列中删除信息，并告诉系统把它们派发到对应的窗口消息处理函数。  
除了WM_PAINT, WM_TIMER和WM_QUIT消息以外，系统总是派发放在在消息队列的末尾的消息。这将保证让一个窗口以first-in, first-out的顺序接收消息。  
WM_PAINT，WM_TIMER，和WM_QUIT消息，会一直被保存在队列中，只有在队列中没有其他消息时才会被派发到窗口消息处理函数。  
此外，同一个窗口的多个WM_PAINT消息被合并成一个WM_PAINT消息，客户区的所有无效部分也会被合并。这样是为了减少窗口重绘客户区的次数。  
windows向线程消息队列传递消息时，首先会填充一个MSG结构，然后将这个MSG结构复制到消息队列。MSG中的信息包括：目标窗口，消息标识符，两个消息参数，消息派发时的时间，鼠标光标位置。一个线程可以使用PostMessage或PostThreadMessage功能向自己的消息队列或者是其他线程的消息队列发送消息。应用程序可以使用GetMessage函数从自己的消息队列中删除消息。查看而不删除消息，用的是PeekMessage函数。PeekMessage函数会返回一个带有消息信息的MSG结构。  
从消息队列中删除消息后，应用程序可以使用DispatchMessage函数指示系统将消息发送到一个窗口消息处理函数。 DispatchMessage的参数是是前一次调用GetMessage或PeekMessage获得的MSG结构的指针。 DispatchMessage会传递窗口句柄，消息标识符，这两个消息参数这些信息给窗口消息处理函数，它不会传递消息派发时间以及鼠标光标位置。应用程序可以在处理消息时调用的GetMessageTime和GetMessagePos来获得这些信息。  
线程可以使用WaitMessage函数，交出自己的控制权，当它的消息队列中没有消息时，调用WaitMessage函数会挂起线程，直到自己的消息队列里有消息时才返回。

+ **非队列消息**  
非队列消息将会绕过系统队列和消息队列，直接将消息发送到窗口过程，。系统发送非队列消息通知窗口，系统发送消息通知窗口。例如,当用户激活一个窗口系统发送WM_ACTIVATE,WM_SETFOCUS, and WM_SETCURSOR。这些消息通知窗口它被激活了。非队列消息也可以由当应用程序调用系统函数产生。例如,当程序调用SetWindowPos系统发送WM_WINDOWPOSCHANGED消息。一些函数也发送非队列消息，如`BroadcastSystemMessage，BroadcastSystemMessageEx，SendMessage，SendMessageTimeout，和SendNotifyMessage`
