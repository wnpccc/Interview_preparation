# C++基础

## 一、虚函数

虚函数是用父类指针指向子类对象，这样从外部指针使用者的角度就表现出同一类型的指针有不同的表现从而实现多态
非指针对象调用函数没有查询虚函数表的步骤，直接根据成员函数和类的绑定关系(编译时确定)调用成员函数  
构造函数设为虚函数 调用构造函数时虚函数表指针未初始化  
构造过程、析构过程中调用虚函数，此时虚函数不一定有虚函数的效果，比如基类构造函数中调用次数子类未构造，不存在子类的虚函数

## 二、内存对齐

如果没有指定的情况下，以到当前声明为止的最长成员的整数倍对齐，否则以指定字节的整数倍对齐

## 三、sizeof相关

sizeof 参数不退化；结果在编译时确定  

+ 指针占内存的大小和编译环境相关

## 四、顶层const和底层const

一个顶层const的形参无法和一个没有顶层const的形参区分开来

顶层：修饰的变量本身是常量
底层：修饰的变量指向的对象是常量  
**作用**  

+ 执行对象拷贝的时候有限制，常量的底层const不能赋给非常量的底层const  
+ 使用函数const_cast时，只能改变运算对象的底层const

## 五、static相关

C++标准定为全局或静态对象首次用到时才会进行构造，并通过atexit()来管理
全局的静态变量和全局变量一起在main函数之前按声明顺序初始化
**作用**

+ 静态局部变量：在函数调用间保持其值，生命周期从程序开始直到程序结束，作用域限于函数内部。
+ 静态全局变量：仅在声明它的文件内有效，其他文件无法访问。
+ 静态成员变量：属于类本身而非某个对象，所有类的对象共享此变量。
+ 静态成员函数：不依赖于对象实例，可以通过类名直接调用，且只能访问静态成员。
+ 静态函数：限制函数作用域仅在声明它的文件内，其他文件无法调用。

## 六、const相关

+ const 关键字的作用是使一个对象或数据变为“常量”，它的值在初始化后不能被修改。
+ 可以用 const 来修饰变量、指针、引用、成员函数(表示该函数不会修改类的任何成员变量，mutable修饰的变量除外)等。

## 七、new/delete

new数组的情况下，指针指向的地址的前四位保存数组大小，以便delete知道需要回收的内存大小

## 八、对象复用

享元模式：创建对象之后保存在对象池中，实现对象的重复利用，减少对象创建的消耗（线程池）

## 九、零拷贝

避免CPU将数据从一块存储拷贝到另外一块存储的技术，如vector中的 **emplace_back()** 函数

## 十、函数返回值

### C

C语言规定将函数返回值放在寄存器中

### C++

#### 基本的返回值传递

1. 值传递（Return by Value）：
当函数返回一个类对象时，如果没有启用RVO/NRVO，编译器会创建一个临时对象来存储返回值。
这个临时对象通常存储在调用者的栈上（即调用该函数的函数的栈帧中）。  
2. 复制/移动构造函数：
在没有RVO/NRVO的情况下，局部对象（函数内部创建的对象）会被复制或移动到临时对象中。
复制或移动操作由类的复制构造函数或移动构造函数完成。

#### 返回值优化（RVO）和命名返回值优化（NRVO）

为了优化性能，现代C++编译器通常会对返回值进行优化

+ **RVO**：编译器可以省略临时对象的创建，直接构造调用者期望的对象。  
+ **NRVO**：如果函数返回的是一个命名的局部变量，编译器可以直接构造调用者期望的对象，并避免不必要的复制或移动。  

C++临时对象的存储位置  

+ 启用RVO/NRVO时：没有临时对象，或者临时对象直接构造为调用者期望的对象。
+ 未启用RVO/NRVO时：临时对象存储在调用者的栈帧中，用于存储从函数返回的局部对象的副本。

## 十一、this指针

this指针在成员函数开始执行前构造，执行结束后清除  
不影响sizeof的对象大小  
不固定存储在某地，一般存储在寄存器
this指针只有在成员函数中才有定义
一般情况下this指针未右值，无法通过&符号获取地址

## 十二、内存泄漏

检查方法：在main函数最后面一行，加上一句_CrtDumpMemoryLeaks()。调试程序，自然关闭程序让其退出，  
查看输出：输出这样的格式{453}normal block at 0x02432CA8,868 bytes long  
被{}包围的453就是我们需要的内存泄漏定位值，868 bytes long就是说这个地方有868比特内存没有释放。  
定位代码位置：
在main函数第一行加上_CrtSetBreakAlloc(453);意思就是在申请453这块内存的位置中断。然后调试程序，程序中断了，查看调用堆栈。加上头文件#include<crtdbg.h>

## 十三、二维数组

以`int arr[3][4]`为例

由于二维数组的本质是一个数组的数组，`arr` 可以被视作指向指针的指针，指向的是第一行数组（即 `int[4]`）。

+ 以下几种形式等价  

```c++
arr[2][3]  
p_arr[2][3]  
*(arr[2]+3)  
*(p_arr[2]+3)  
*(*(arr+2)+3)  
*(*(p_arr+2)+3)  
*(p_arr+2*4+3)
```

+ new返回一维数组的指针

```C++
int (*p_3_4)[4]=new int[3][4]()
```
